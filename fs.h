/*
 * Copyright (c) 2025, Jan de Visser <jan@finiandarcy.com>
 *
 * SPDX-License-Identifier: MIT
 */

#ifndef __FS_H__
#define __FS_H__

#ifdef FS_TEST
#define SLICE_IMPLEMENTATION
#define DA_IMPLEMENTATION
#define FS_IMPLEMENTATION
#endif /* FS_TEST */

#include "da.h"
#include "slice.h"

typedef enum _path_kind {
    PATH_UNDEFINED = 0,
    PATH_RELATIVE,
    PATH_ABSOLUTE,
} path_kind_t;

typedef struct _path {
    path_kind_t kind;
    sb_t        path;
    slices_t    components;
} path_t;

path_t  path_initialize(path_kind_t kind, ...);
path_t  path_parse(slice_t p);
path_t  path_extend(path_t p, slice_t sub);
slice_t path_extension(path_t *path);
path_t *path_replace_extension(path_t *path, slice_t ext);
void    path_free(path_t *path);

#define path_make_relative(...) path_initialize(PATH_RELATIVE, ##__VA_ARGS__, NULL);

#endif /* __FS_H__ */

#ifdef FS_IMPLEMENTATION
#ifndef FS_IMPLEMENTED

static void path_reparse(path_t *path)
{
    dynarr_clear(&path->components);
    path->kind = PATH_UNDEFINED;
    if (path->path.len == 0) {
        return;
    }
    slice_t p = sb_as_slice(path->path);
    path->kind = PATH_RELATIVE;
    if (p.items[0] == '/') {
        path->kind = PATH_ABSOLUTE;
        p = slice_tail(p, 1);
        if (p.len == 0) {
            return;
        }
    }
    opt_size_t slash = slice_indexof(p, '/');
    while (p.len > 0 && slash.ok) {
        slice_t c = slice_first(p, slash.value);
        dynarr_append(&path->components, c);
        p = slice_tail(p, slash.value + 1);
        slash = slice_indexof(p, '/');
    }
    if (p.len > 0) {
        dynarr_append(&path->components, p);
    }
}

path_t path_initialize(path_kind_t kind, ...)
{
    path_t ret = { 0 };
    ret.kind = (kind != PATH_ABSOLUTE) ? PATH_RELATIVE : PATH_ABSOLUTE;
    if (ret.kind == PATH_ABSOLUTE) {
        sb_append_char(&ret.path, '/');
    }
    va_list args;
    va_start(args, kind);
    for (char *c = va_arg(args, char *); c != NULL; c = va_arg(args, char *)) {
        size_t len = strlen(c);
        if (len == 0) {
            continue;
        }
        if (ret.path.len > 1 || (ret.path.len == 1 && ret.path.items[0] != '/')) {
            sb_append_char(&ret.path, '/');
        }
        sb_append_cstr(&ret.path, c);
    }
    va_end(args);
    path_reparse(&ret);
    return ret;
}

path_t path_parse(slice_t p)
{
    path_t ret = { 0 };
    sb_append(&ret.path, p);
    path_reparse(&ret);
    return ret;
}

path_t path_extend(path_t p, slice_t sub)
{
    path_t ret = { 0 };
    ret.kind = p.kind;
    sb_append_sb(&ret.path, p.path);
    if (ret.path.len > 1 || (ret.path.len == 1 && ret.path.items[0] != '/')) {
        sb_append_char(&ret.path, '/');
    }
    sb_append(&ret.path, sub);
    path_reparse(&ret);
    return ret;
}

void path_free(path_t *p)
{
    sb_free(&p->path);
    *p = (path_t) { 0 };
}

slice_t path_extension(path_t *path)
{
    if (path->components.len == 0) {
        return (slice_t) { 0 };
    }
    slice_t last = *dynarr_back(&path->components);
    assert(last.len > 0);
    opt_size_t dot = slice_last_indexof(last, '.');
    if (dot.ok) {
        return slice_tail(last, dot.value);
    }
    return (slice_t) { 0 };
}

path_t *path_replace_extension(path_t *path, slice_t ext)
{
    if (path->components.len == 0 || ext.len == 0) {
        return path;
    }
    slice_t last = *dynarr_back(&path->components);
    assert(last.len > 0);
    opt_size_t dot = slice_last_indexof(last, '.');
    if (dot.ok) {
        path->path.len = (last.items - path->path.items) + dot.value;
    }
    if (ext.items[0] != '.') {
        sb_append_char(&path->path, '.');
    }
    sb_append(&path->path, ext);
    path_reparse(path);
    return path;
}

#define FS_IMPLEMENTED
#endif /* FS_IMPLEMENTED */
#endif /* FS_IMPLEMENTATION */

#ifdef FS_TEST

int main()
{
    path_t p = path_make_relative("foo", "bar", "baz");
    assert(p.components.len == 3);
    assert(p.kind == PATH_RELATIVE);
    p = path_parse(C("a/b/c/d"));
    assert(p.components.len == 4);
    assert(p.kind == PATH_RELATIVE);
    p = path_parse(C("/a/b/c/d/e"));
    assert(p.components.len == 5);
    assert(p.kind == PATH_ABSOLUTE);

    p = path_make_relative("foo", "bar.c");
    assert(slice_eq(p.components.items[1], C("bar.c")));
    assert(slice_eq(path_extension(&p), C(".c")));
    path_replace_extension(&p, C(".h"));
    assert(slice_eq(path_extension(&p), C(".h")));
    path_replace_extension(&p, C("o"));
    assert(slice_eq(path_extension(&p), C(".o")));
}

#endif /* FS_TEST */
